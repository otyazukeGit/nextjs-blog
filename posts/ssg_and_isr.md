---
title: "Summarized the Qiita article about SSR and ISR"
date: "2021-06-01"
---

# SSR と ISR についての記事から自分なりのまとめ

## 概要

- 以下の Qiita 記事を中心に、SSG や ISR が何か？どんな時に採用するか？を今の理解で自分なりにまとめる。
- 本件は Next.js + Vercel 利用を前提とする。
- SPA は細かい切り分けが整理できてないので一旦外しておく。

参考：[Next.js における SSG（静的サイト生成）と ISR について（自分の）限界まで丁寧に説明する](https://qiita.com/thesugar/items/47ec3d243d00ddd0b4ed)

## WEB への配信または準備

以下のパターンで考える

- CSR (Client Side Rendering)
- SSR (Server Side Rendering)
- SSG (Static Site Generation)
- ISR (Incremental Static Regeneration)

## 採用基準

どの形式を採用するかの考慮要素

- SEO
- ブラウザに表示されるまでの時間
- ページ生成の途中をユーザに見せるか
- 旧ページをユーザに見せていいのか
  - 頻度
  - キャッシュ

## まとめ

- リアルタイム性が求められないページなら SSG 一択かもしれない（Next.js 公式も推奨）
  - (ビルド以外で)動的 path が増えていく場合、フォールバック(true or blocking)
  - ISR(インクリメンタル静的再生成)で各ページの段階的な最新化は可能
    - しかし、アプリ全体のリビルドがいらないが、ページの最新でないタイミングはできてしまう。
- 静的にページを事前にレンダリングしておく必要もないページ（事前にレンダリングできないページ）
  - SSG や ISR でカバーできない気がする
  - SPA(動的データ取得) or SSR
    - **このあたり試してみるか更に調べる**

---

## CSR (Client Side Rendering)

### 概要

クライアントサイド・レンダリング
WEB サーバへアクセスし、HTML/CSS/JS をダウンロードしてブラウザ側でページをレンダリングする

### メリット

- 最低限必要なものは HTML ファイル、JS ファイルのみであり構成がシンプル。
  - この 2 つをホスティング先に置いておけばとりあえずページは表示される

### デメリット

- JS ファイルが実行、評価されて DOM がマウントされるまでコンテンツが何も表示されない
- JS ファイルのサイズが大きくなると、ファイルダウンロードの時間が無視できないレベルになる
  - SPA など初回のダウンロードと処理が重くなる
- 変更がない部分(ヘッダーなど)の HTML も毎回サーバーから送信されるので処理に時間がかかる

### どんな時に選ぶか

- 単純な静的ページ
  - SSG で良い気がする

---

## SSR (Server Side Rendering)

### 概要

- サーバサイド・レンダリング
- クライアントからサーバへリクエストがあった時に"サーバ側"でレンダリングして、配信する。
- SPA ではブラウザで行われていた「JS の実行と HTML 生成をサーバー側で行う」技術
- Ajax などで HTTPS リクエストを送信する部分は SPA と同様です。

### メリット

- サーバー側で HTML を生成するので
  - ページ表示が早い(SPA の欠点である初回読み込みの遅さも無い)
  - ユーザーの通信環境に左右されにくい
- 要するに、ブラウザの大半の仕事をサーバー側に任せ、ブラウザの仕事は最後の描画だけ
- SSR は、リクエストごとに HTML を生成するため、常に最新の状態をユーザーに見せることができる
- Ajax などでデータを取得して差分だけ描画できる
- Next.js で SSR がかんたんに扱える

### デメリット

- アクセスの度にサーバサイドレンダリングが走るので、レンダリング時間がかかる
- SEO 対策が要る（最近は状況変わった？）

### どんな時に選ぶか？

- SPA より高速にしたい（ユーザ環境に依存させない）
- 常に最新を配信したい

---

## SSG (Static Site Generation)

### 概要

- 静的ジェネレーター　 Next.js( ~ Ver. 9.3)
- SSR も結局サーバサイドでレンダリングする時間が掛かっている。
- ビルド時点で静的ページをレンダリングしておいて配信するだけにする。
- CDN に HTML ファイルのキャッシュを配置しておき、各ユーザーに近い CDN からそのキャッシュを返す、という方法を取ることが有効

* Vercel は Vercel Edge Network という CDN がデフォルトである

### 考慮

- 外部データを取得する場合
  - プリレンダリングした静的ページ以後の更新されたデータを取得したい
  - クライアント側で Ajax などで取得するなら CSR と変わりないのでは？
  - SSR なら解決するが前述(SSR の項)のデメリット問題になる
- どう解決するのか？
  - path の追加に関しては、後述の SSG(fallback:true or blocking)で対処できそう
- 時間の経過に応じて変化するデータに対しては？動的データは？
  - この対処が、ISR(インクリメンタル静的再生性)

### SSG を実現する関数

- getStaticPaths()
  - return { paths: [{params: { hoge: hoge}}, ... ]} , fallback: false }
  - ビルド時に静的にレンダリングするパスの一覧を決めておく関数
  - 動的ルーティングと組み合わせることで外部データを要するページが複数存在する Web アプリケーションでもページ生成が簡単になる。
- getStaticProps(context)
  - return { props: { hoge: hoge } }
  - ビルド時に実行され、そのタイミング（＝ビルド時）で props がページコンポーネントに渡される

### getStaticPaths の fallback

- fallback:false の場合
  - 指定された path 以外が指定された場合、404 エラーになる
  - 他ユーザによる追加など(外部要因)で path が変わる場合は、対処できない
- fallback:true の場合
  - 指定された path 以外が指定された場合、データ取得を要する部分以外がレンダリングされた静的なページにフォールバック (fallback) される
    - Request 1 回目
      - クライアント（ブラウザ）に対して、取得を要するデータが欠けた状態の HTML がサーブされる
      - 不完全な HTML を受け取ったクライアント側でデータ取得が行われる（Next.js が Ajas 処理など追記してくれるのか？
        - 不足分は取得されて補完される。クライアントサイド・レンダリングと同様の形になる。
      - 同時に、バックグラウンド（サーバー）側でも同様に JavaScript が実行される
        - 必要なデータの取得とレンダリング（HTML の生成）が行われる（CDN に置かれる？
        - そのパスは、以降のユーザーからのリクエストに対しては、サーバー側で生成した HTML（のキャッシュ:CDN）を返す
        - 他のプリレンダリングされたページと同じ状態になる
    - Request 2 回目（他のクライアントユーザ含む）
      - CDN からリンダリング済 HTML を取得
- fallback:blocking の場合
  - fallback:true と基本同じだが、不完全 HTML はサーブしない。フォールバックをブロックする。
    - 代わりにサーバサイド・レンダリングが働いてレンダリング HTML をサーブする。

### メリット

- Web サーバーは置いてある HTML ファイルを返すだけなのでサーバー負荷は小さく、爆速
- 動的コンテンツは ajax などの非同期リクエストで対応
- Next.js で SSR がかんたんに扱える

### デメリット

- プリレンダリングページが多い/大きいとビルドが長くなる。

### どんな時に選ぶか？

- 基本的に SSG 一択でいいのかも？
- サイト構成や特性に応じて、データ変化をどこまで追うかでフォールバックや ISR を検討
- リアルタイム性が必要なページには使えない。SPA or SSR を検討

---

## ISR (Incremental Static Regeneration)

### 概要

- インクリメンタル静的生成　 Next.js( ~ Ver. 9.5)
- SSG の挙動に加えて、一定時間ごとにバックグラウンドでデータの再取得および再レンダリングを行い、HTML を再生成 (regenerate) する手法

### ISR を実現する関数

- getStaticProps(context)
  - return に revalidate を足す
  - revalidate: 秒数
  - 「指定した時間が経過した後の初めてのリクエスト」がトリガーとなり、そのページが対象になる。
    - 再データ取得＆再レンダリング（CDN キャッシュ登録）
    - バックグラウンドで再レンダリング 2 回目後に最新がサーブされるので、リクエスト 1 回目は古い(プリレンダリング時点)になる。

### メリット

- 段階的にレンダリングを行うのでアプリ全体をビルドし直す必要がない。

### デメリット

- データが変わっていくようなページでは、リアルタイムで最新をサーブできない
  - リクエスト 1 回目は古い(プリレンダリング時点)になる。
- revaldate を短くすると最新化するまでの時間は短くなるがレンダリングが増えてサーバ負荷が高まる

### どんな時に選ぶか？

- リアルタイムでないにせよ、データの変化が致命的でないページ？
